"""
parse_tvd library is used for parsing 2D TVD files generated by "Teravil Spectrometer 2D" software.
v. 0.1

Works: multiple 2D TVD file scan parsing
TODO: some fields are not recognized; there is some data after response values that are not recognized


Copyright (C) Domas Jokubauskis (2024)

parse_tvd is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

parse_tvd is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with parse_tvd.  If not, see <http://www.gnu.org/licenses/>.

"""
import os
import struct
import binascii
from pathlib import Path
import logging
import matplotlib.pyplot as plt
import numpy as np
logging.basicConfig(level=logging.INFO)

def find_float(field: bytes):
    "utility function for binary analysis"
    for i in range(len(field)):
        position = i
        value = struct.unpack('<d', field[position:position+8])[0]
        line = f"{position}\t{value}\n"
        print(line)
        if value>1.742e-15 and value<1.744e-15:
            print(position, value)
            #break
        if position>=len(field):
            break

def process_data_section(field: bytes, file_name, name):
    value_count = struct.unpack('<L', field[:4])[0]
    field = field[4:]
    position = 0
    DATA_START = 136
    STEP_POSITION = 103
    # identical: 00-03,  0f-46, 56-76, 7b-7e , 83-87

    REFERENCE_BYTE_POSITION = 8 # reference - 0, measurement - 1
    reference_byte = struct.unpack('<B', field[REFERENCE_BYTE_POSITION:REFERENCE_BYTE_POSITION+1])[0]
    is_reference = False
    if reference_byte == 0:
        is_reference = True
    STEP_X_POSITION = 34
    step_x = struct.unpack('<d', field[STEP_X_POSITION:STEP_X_POSITION+8])[0]

    STEP_Y_POSITION = 42
    step_y = struct.unpack('<d', field[STEP_Y_POSITION:STEP_Y_POSITION+8])[0]

    INDEX4_POSITION = 4
    index4 = struct.unpack('<B', field[INDEX4_POSITION:INDEX4_POSITION+1])[0]
    INDEX6_POSITION = 5
    index6 = struct.unpack('<H', field[INDEX6_POSITION:INDEX6_POSITION+2])[0]
    #INDEX3_POSITION = 6
    #index3 = struct.unpack('<B', field[INDEX3_POSITION:INDEX3_POSITION+1])[0]
    
    X_POSITION = 10
    x_index = struct.unpack('<B', field[X_POSITION:X_POSITION+1])[0]
    Y_POSITION = 14
    y_index = struct.unpack('<B', field[Y_POSITION:Y_POSITION+1])[0]
    time_step = struct.unpack('<d', field[STEP_POSITION:STEP_POSITION+8])[0]
    position = DATA_START
    values = struct.unpack(f'<{value_count}d', field[DATA_START:DATA_START+8*value_count])
    values = np.array(values)
    position = position+8*value_count
    #print(f"length {len(field)} {position=}, lieka {len(field)- position}")
    #print(values[0], values[-1-1])
    
    #print(binascii.b2a_hex(field[position:position+136], " "))
    #print(len(field[position:]))
    return {"file_name": file_name,
            "name": name.replace(b"\x5F", b" ").decode().strip(),
            "value_count": value_count,
            "is_reference": is_reference, 
            "time_step": time_step,
            "step_x": step_x, # maybe reversed with y
            "step_y": step_y,
            "x_index": x_index,
            "y_index": y_index, 
            "x": step_x*x_index,
            "y": step_y*y_index,
            
            "i4": index4, 
            #"index5": index5, 
            "i6": index6,
            }, values

FIRST_FILE_HEADER = b"TVD001"
NAME_LENGTH = 20

def read_tvd_file(file_path: Path, write_output_file=False):
    logging.debug(f"Reading file {file_path.name}")
    file = open(file_path, "b+r")
    file.seek(0, 2)
    file_size = file.tell()
    file.seek(0)
    
    if write_output_file: out_file = open(file_path.with_suffix(file_path.suffix+".out"), "t+w")
    file_header = file.read(len(FIRST_FILE_HEADER))
    if not file_header == FIRST_FILE_HEADER and file_header == b'TVD_Pr': # files 
        file.seek(0)
    else:
        assert file_header == FIRST_FILE_HEADER, f"Bad file header: {file_header} instead of {FIRST_FILE_HEADER}"
    #print(binascii.b2a_hex(bytes([i for i in range(140)]), " "))
    next_file = None
    previous_file = None
    sections = []
    while True:
        section_position = file.tell()
        #print(section_position)
        if section_position == file_size:
            break
        if section_position>file_size:
            raise ValueError(f"Read out of file bounds, {file_size=}, {section_position=}")
        name = file.read(NAME_LENGTH)
        assert name.startswith(b"TVD"), f"Section {name=} should start with 'TVD'"
        data_section = False
        if name in [b'TVD_Reference_______', b'TVD_Current_________']:
            data_section = True
        section_length = struct.unpack('<L', file.read(4))[0]
        section_content = file.read(section_length)
        
        if data_section:
            section_info, values = process_data_section(section_content, file_path.name, name)
            sections.append([section_info, values])
        #print(name, section_length)
        section_info = None
        if write_output_file: 
            line = f"{section_position}\t{str(name)}\t{section_length}\t{str(section_info)}\t{str(section_content[:14])}\n"
            out_file.write(line)
        if name == b"TVD_PreviousFile____":
            previous_file = section_content.decode().strip()
            logging.debug(f"Previous file: {previous_file}")
        if name == b'TVD_FilesCount______':
            section_length -= 0#1
        file.seek(section_position + NAME_LENGTH + section_length + 4, os.SEEK_SET)
        if name == b'TVD_NextFile________':
            next_file = section_content.decode().strip()
            logging.debug(f"Next file: {next_file}")
            if next_file == "MEASUREMENT_NEEDS_RENAMING.tvd1": # probably default file name, should None
                next_file = None
            break
    if write_output_file: out_file.close()
    assert file.tell() == file_size, f"File {file_path} is not read completely"
    file.close()
    if next_file is not None:
        return sections, file_path.with_name(next_file)
    return sections, next_file

def plot_response(data, reference=None):
    fig, ax = plt.subplots(1, 1, tight_layout=True)
    section_info, values = data
    t = np.arange(0., len(values)*section_info["time_step"], section_info["time_step"])
    plt.plot(t, values)
    plt.xlabel(f"t, s")
    plt.ylabel(section_info["name"])
    plt.title = f'{section_info["file_name"]}, {section_info["x"]=}, {section_info["y"]=}'
    ax.plot(t, values, label="data")
    if reference is not None:
        ax.plot(t, reference[1], label="reference")
    ax.legend(loc='upper right')

def plot_file_coordinates(data):
    fig, ax = plt.subplots(1, 1, tight_layout=True)

    ax.set(title='File data distribution')
    plt.xlabel('x, m')
    plt.ylabel('y, m')
    markers = ['go', 'r+', 'b*', 'm+']*5
    
    previous_file_name = None
    for section in data:
        section_info, values = section
        label = None
        if not  previous_file_name == section_info["file_name"]:
            marker = markers.pop()
            previous_file_name = section_info["file_name"]
            label = section_info["file_name"]
        # plot a single point
        ax.plot(section_info["x"], section_info["y"], marker, label=label)
    ax.legend(loc='upper right')

def read_tvd_files(file_path: Path):
    results = []
    while True:
        sections, next_file = read_tvd_file(file_path)
        results.extend(sections)
        if next_file is None:
            break
        file_path = next_file
    logging.info(f"Total number of sections: {len(results)}")
    return results

if __name__ == "__main__":
    file_path = Path("Si+gold.tvd")
    data = read_tvd_files(file_path)
    plot_file_coordinates(data)
    reference = None
    reference = data[0]
    reference[1] = reference[1]/np.max(reference[1])
    section = data[50]
    section[1] = section[1]/np.max(section[1])
    plot_response(section, reference=reference)
